<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [ZooKeeper 是什么？](#zookeeper-%E6%98%AF%E4%BB%80%E4%B9%88)
- [ZooKeeper 设计目标](#zookeeper-%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87)
  - [简单的数据模型](#%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B)
  - [可构建集群](#%E5%8F%AF%E6%9E%84%E5%BB%BA%E9%9B%86%E7%BE%A4)
  - [顺序访问](#%E9%A1%BA%E5%BA%8F%E8%AE%BF%E9%97%AE)
  - [高性能](#%E9%AB%98%E6%80%A7%E8%83%BD)
- [ZooKeeper 提供了什么？](#zookeeper-%E6%8F%90%E4%BE%9B%E4%BA%86%E4%BB%80%E4%B9%88)
- [Zookeeper 文件系统](#zookeeper-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F)
- [Zookeeper 怎么保证主从节点的状态同步？](#zookeeper-%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%BB%E4%BB%8E%E8%8A%82%E7%82%B9%E7%9A%84%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5)
  - [恢复模式](#%E6%81%A2%E5%A4%8D%E6%A8%A1%E5%BC%8F)
  - [广播模式](#%E5%B9%BF%E6%92%AD%E6%A8%A1%E5%BC%8F)
- [四种类型的数据节点 Znode](#%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9-znode)
  - [持久节点](#%E6%8C%81%E4%B9%85%E8%8A%82%E7%82%B9)
  - [临时节点](#%E4%B8%B4%E6%97%B6%E8%8A%82%E7%82%B9)
  - [持久顺序节点](#%E6%8C%81%E4%B9%85%E9%A1%BA%E5%BA%8F%E8%8A%82%E7%82%B9)
  - [临时顺序节点](#%E4%B8%B4%E6%97%B6%E9%A1%BA%E5%BA%8F%E8%8A%82%E7%82%B9)
- [Zookeeper 的典型应用场景](#zookeeper-%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF)
- [Zookeeper的通知机制](#zookeeper%E7%9A%84%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6)
- [Zookeeper的分布式锁实现方式](#zookeeper%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F)
- [Zookeeper 采用的哪种分布式一致性协议? 还有哪些分布式一致性协议](#zookeeper-%E9%87%87%E7%94%A8%E7%9A%84%E5%93%AA%E7%A7%8D%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE-%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE)
  - [ZAD和Paxos算法的联系和区别](#zad%E5%92%8Cpaxos%E7%AE%97%E6%B3%95%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB)
- [Zookeeper 是怎样保证主从节点的状态同步](#zookeeper-%E6%98%AF%E6%80%8E%E6%A0%B7%E4%BF%9D%E8%AF%81%E4%B8%BB%E4%BB%8E%E8%8A%82%E7%82%B9%E7%9A%84%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5)
- [集群中为什么要有主节点](#%E9%9B%86%E7%BE%A4%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E4%B8%BB%E8%8A%82%E7%82%B9)
- [leader 选举过程](#leader-%E9%80%89%E4%B8%BE%E8%BF%87%E7%A8%8B)
- [Zookeeper与Eureka的区别](#zookeeper%E4%B8%8Eeureka%E7%9A%84%E5%8C%BA%E5%88%AB)
  - [结构上](#%E7%BB%93%E6%9E%84%E4%B8%8A)
  - [高可用与强一致性](#%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B8%8E%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7)
  - [Eureka的自我保护机制](#eureka%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->


# ZooKeeper 是什么？
ZooKeeper 是一个开源的分布式协调服务。它是一个为分布式应用提供一致性服务的软件，分布式应用程序可以基于 Zookeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。

ZooKeeper 的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。

Zookeeper 保证了如下分布式一致性特性：
1. 顺序一致性
2. 原子性
3. 单一视图
4. 可靠性
5. 实时性（最终一致性）

客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上注册了监听器，这个监听器也是由所连接的 zookeeper 机器来处理。对于写请求，这些请求会同时发给其他 zookeeper 机器并且达成一致后，请求才会返回成功。因此，随着 zookeeper 的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。

有序性是 zookeeper 中非常重要的一个特性，所有的更新都是全局有序的，每个更新都有一个唯一的时间戳，这个时间戳称为 zxid（Zookeeper Transaction Id）。而读请求只会相对于更新有序，也就是读请求的返回结果中会带有这个zookeeper 最新的 zxid。

# ZooKeeper 设计目标
## 简单的数据模型
ZooKeeper 允许分布式进程通过共享的层次结构命名空间进行相互协调，这与标准文件系统类似。 名称空间由 ZooKeeper 中的数据寄存器组成 - 称为znode，这些类似于文件和目录。 与为存储设计的典型文件系统不同，ZooKeeper数据保存在内存中，这意味着ZooKeeper可以实现高吞吐量和低延迟。

![](https://github.com/zaiyunduan123/Java-Interview/blob/master/image/Zookeeper-1.png)

## 可构建集群
为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么zookeeper本身仍然是可用的。 客户端在使用 ZooKeeper 时，需要知道集群机器列表，通过与集群中的某一台机器建立 TCP 连接来使用服务，客户端使用这个TCP链接来发送请求、获取结果、获取监听事件以及发送心跳包。如果这个连接异常断开了，客户端可以连接到另外的机器上。

ZooKeeper 官方提供的架构图：

![](https://github.com/zaiyunduan123/Java-Interview/blob/master/image/Zookeeper-2.png)

上图中每一个Server代表一个安装Zookeeper服务的服务器。组成 ZooKeeper 服务的服务器都会在内存中维护当前的服务器状态，并且每台服务器之间都互相保持着通信。集群间通过 Zab 协议（Zookeeper Atomic Broadcast）来保持数据的一致性。

## 顺序访问
对于来自客户端的每个更新请求，ZooKeeper 都会分配一个全局唯一的递增编号，这个编号反应了所有事务操作的先后顺序，应用程序可以使用 ZooKeeper 这个特性来实现更高层次的同步原语。 这个编号也叫做时间戳——zxid（Zookeeper Transaction Id）
 
## 高性能
ZooKeeper 是高性能的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）


# ZooKeeper 提供了什么？
- 文件系统
- 通知机制

# Zookeeper 文件系统
Zookeeper 提供一个多层级的节点命名空间（节点称为 znode）。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。

Zookeeper 为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得 Zookeeper 不能用于存放大量的数据，每个节点的存放数据上限为1M。

# Zookeeper 怎么保证主从节点的状态同步？
Zookeeper 的核心是原子广播机制，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 Zab 协议。Zab 协议有两种模式，它们分别是恢复模式和广播模式。

## 恢复模式
当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。

## 广播模式
一旦 leader 已经和多数的 follower 进行了状态同步后，它就可以开始广播消息了，即进入广播状态。这时候当一个 server 加入 ZooKeeper 服务中，它会在恢复模式下启动，发现 leader，并和 leader 进行状态同步。待到同步结束，它也参与消息广播。ZooKeeper 服务一直维持在 Broadcast 状态，直到 leader 崩溃了或者 leader 失去了大部分的 followers 支持。


# 四种类型的数据节点 Znode
## 持久节点
除非手动删除，否则节点一直存在于 Zookeeper 上

## 临时节点
临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与zookeeper 连接断开不一定会话失效），那么这个客户端创建的所有临时节点都会被移除。

## 持久顺序节点
基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。

## 临时顺序节点
基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。

# Zookeeper 的典型应用场景
Zookeeper 是一个典型的发布/订阅模式的分布式数据管理与协调框架，开发人员可以使用它来进行分布式数据的发布和订阅。

通过对 Zookeeper 中丰富的数据节点进行交叉使用，配合 Watcher 事件通知机制，可以非常方便的构建一系列分布式应用中年都会涉及的核心功能，如：
1. 数据发布/订阅
2. 负载均衡
3. 命名服务
4. 分布式协调/通知
5. 集群管理
6. Master 选举
7. 分布式锁
8. 分布式队列


# Zookeeper的通知机制
客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。

# Zookeeper的分布式锁实现方式
在讲zk分布锁之前，先看下zookeeper中几个关于节点的有趣的性质：
1. 有序节点：假如当前有一个父节点为/lock，我们可以在这个父节点下面创建子节点；zookeeper提供了一个可选的有序特性，例如我们可以创建子节点“/lock/node-”并且指明有序，那么zookeeper在生成子节点时会根据当前的子节点数量自动添加整数序号，也就是说如果是第一个创建的子节点，那么生成的子节点为/lock/node-0000000000，下一个节点则为/lock/node-0000000001，依次类推。
2. 临时节点：客户端可以建立一个临时节点，在会话结束或者会话超时后，zookeeper会自动删除该节点。
3. 事件监听：在读取数据时，我们可以同时对节点设置事件监听，当节点数据或结构变化时，zookeeper会通知客户端。当前zookeeper有如下四种事件：
1、节点创建；2、节点删除；3、节点数据修改；4、子节点变更。

下面描述使用zookeeper实现分布式锁的算法流程，假设锁空间的根节点为/lock：

1. 客户端连接zookeeper，并在/lock下创建临时的且有序的子节点，第一个客户端对应的子节点为/lock/lock-0000000000，第二个为/lock/lock-0000000001，以此类推。
2. 客户端获取/lock下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁，否则监听/lock的子节点变更消息，获得子节点变更通知后重复此步骤直至获得锁；
3. 执行业务代码；
4. 完成业务流程后，删除对应的子节点释放锁。

# Zookeeper 采用的哪种分布式一致性协议? 还有哪些分布式一致性协议

zab协议是zookeeper专门设计的支持崩溃恢复的原子广播协议。目的是实现分布式zoopkeeper各个节点数据一致性。

zab协议约定zk节点有两种角色leader和follower,zk客户端会随机的链接到 zookeeper 集群中的一个节点，如果是读请求，就直接从当前节点中读取数据；如果是写请求，那么节点就会向 Leader 提交事务，Leader 接收到事务提交，会广播该事务，只要超过半数节点写入成功，该事务就会被提交。

ZAB协议包括两种基本的模式：消息广播和崩溃恢复。

整个 Zookeeper 就是在这两个模式之间切换。 简而言之，当 Leader 服务可以正常使用，就进入消息广播模式，当 Leader 不可用时，则进入崩溃恢复模式。

以上其实大致经历了三个步骤：
1. 崩溃恢复：主要就是Leader选举过程。
2. 数据同步：Leader服务器与其他服务器进行数据同步。
3. 消息广播：Leader服务器将数据发送给其他服务器。

支持崩溃恢复后数据准确性的就是数据同步了，数据同步基于事务的 ZXID 的唯一性来保证。通过 + 1 操作可以辨别事务的先后顺序。

## ZAD和Paxos算法的联系和区别
共同点：
1. 两者都存在一个类似于Leader进程的角色，由其负责协调多个Follow进程的运行。
2. Leader进程都会等待超过半数的Follower做出正确的反馈后，才会将一个提案进行提交。
3. 在ZAB协议中，每个Proposal中都包含了一个epoch值，用来代表当前Leader周期，在Paxos算法中，同样存在这样一个标识，只是名字变成了Ballot。
不同点：

Paxos算法中，一个新的选举产生的主进程会进行两个阶段的工作
1. 读阶段，新的主进程会通过和所有其他进程进行通信的方式来搜集上一个主进程提出的提案，并将它们提交。
2. 写阶段，当前主进程开始提出它自己的提案。
3. ZAB在Paxos基础上额外添加一个同步阶段。同步阶段之前，ZAB协议存在一个和Paxos读阶段类似的发现（Discovery）阶段

同步阶段中，新的Leader会确保存在过半的Follower已经提交了之前Leader周期中的所有事务Proposal
- 发现阶段的存在，确保所有进程都已经完成对之前所有事物Proposal的提交
- ZAB协议主要用于构建一个高可用的分布式数据主备系统，例如ZooKeeper，Paxos算法则是用于构建一个分布式的一致性状态机系统

# Zookeeper 是怎样保证主从节点的状态同步
Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。

恢复模式：当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。

因此，选主得到的leader保证了同步状态的进行，状态同步又保证了leader和Server具有相同的系统状态，当leader失去主权后可以在其他follower中选主新的leader。

# 集群中为什么要有主节点
在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，
 
其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点


# leader 选举过程
有两种情况会发起Leader选举：
1. 服务器启动的时候
2. 服务器运行的时候当Leader宕机


在讲解流程之前，先说明一下选举流程中涉及到的角色：

- LOOKING：寻找Leader状态，处于该状态需要进入选举流程（只有该节点才可以投票）
- LEADING：领导者状态，处于该状态的节点说明是角色已经是Leader
- FOLLOWING：跟随者状态，表示Leader已经选举出来，当前节点角色是follower
- OBSERVER：观察者状态，表明当前节点角色是observer（该节点不参与竞选）



三个核心选举原则：

1.  Zookeeper集群中只有超过半数以上的服务器启动，集群才能正常工作；
2. 在集群正常工作之前，myid小的服务器给myid大的服务器投票，直到集群正常工作，选出Leader；
3. 选出Leader之后，之前的服务器状态由Looking改变为Following，以后的服务器都是Follower。



下面以一个简单的例子来说明整个选举的过程：

假设有五台服务器组成的Zookeeper集群，它们的id从1-5，同时它们都是最新启动的，也就是没有历史数据，在存放数据量这一点上，都是一样的。

![](https://github.com/zaiyunduan123/Java-Interview/blob/master/image/Zookeeper-2.png)

假设这些服务器从id1-5，依序启动：

因为一共5台服务器，只有超过半数以上，即最少启动3台服务器，集群才能正常工作。

**（1）服务器1启动，发起一次选举。**
服务器1投自己一票。此时服务器1票数一票，不够半数以上（3票），选举无法完成；

服务器1状态保持为LOOKING；

**（2）服务器2启动，再发起一次选举。**

服务器1和2分别投自己一票，此时服务器1发现服务器2的id比自己大，更改选票投给服务器2；

此时服务器1票数0票，服务器2票数2票，不够半数以上（3票），选举无法完成；

服务器1，2状态保持LOOKING；

**（3）服务器3启动，发起一次选举。**

与上面过程一样，服务器1和2先投自己一票，然后因为服务器3id最大，两者更改选票投给为服务器3；

此次投票结果：服务器1为0票，服务器2为0票，服务器3为3票。此时服务器3的票数已经超过半数（3票），服务器3当选Leader。

服务器1，2更改状态为FOLLOWING，服务器3更改状态为LEADING；

**（4）服务器4启动，发起一次选举。**

此时服务器1，2，3已经不是LOOKING状态，不会更改选票信息。交换选票信息结果：服务器3为3票，服务器4为1票。

此时服务器4服从多数，更改选票信息为服务器3；

服务器4并更改状态为FOLLOWING；

**（5）服务器5启动，同4一样投票给3，此时服务器3一共5票，服务器5为0票；**

服务器5并更改状态为FOLLOWING；

**（6）选举结果**

最终Leader是服务器3，状态为LEADING；

其余服务器是Follower，状态为FOLLOWING。

# Zookeeper与Eureka的区别
## 结构上
1、Zookeeper是主从架构
2、Eureka是点对点，节点都是平级的

## 高可用与强一致性
1、Zookeeper当master挂了，会在30-120s进行leader选举，这点类似于redis的哨兵机制，在选举期间Zookeeper是不可用的，这么长时间不能进行服务注册，是无法忍受的，别说30s，5s都不能忍受。这时Zookeeper集群会瘫痪，这也是Zookeeper的CP，保持节点的一致性，牺牲了A/高可用。而Eureka不会，，这就是AP，牺牲了C/一致性。

2、即使Eureka有部分挂掉，还有其他节点可以使用的，他们保持平级的关系，只不过信息有可能不一致。

当坏掉的服务恢复的时候，会自动加入到节点上，也是高可用的一种。然后退出自我保护机制，这也是应对网络异常的一种机制

## Eureka的自我保护机制
在默认配置中，Eureka Server在默认90s没有得到客户端的心跳，则注销该实例，但是往往因为微服务跨进程调用，网络通信往往会面临着各种问题，比如微服务状态正常，但是因为网络分区故障时，Eureka Server注销服务实例则会让大部分微服务不可用，这很危险，因为服务明明没有问题。

为了解决这个问题，Eureka 有自我保护机制，通过在Eureka Server配置如下参数，可启动保护机制
```
eureka.server.enable-self-preservation=true
```

如果在**15分钟内超过85%的节点**都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了**网络故障**，此时会出现以下几种情况：
1. Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务
2. Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用)
3. 当网络稳定时，当前实例新的注册信息会被同步到其它节点中

它的原理是，**当Eureka Server节点在短时间内丢失过多的客户端时（可能发送了网络故障），那么这个节点将进入自我保护模式，不再注销任何微服务，当网络故障恢复后，该节点会自动退出自我保护模式**。

自我保护模式的架构哲学是宁可放过一个，决不可错杀一千


